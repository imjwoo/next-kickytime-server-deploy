name: ECS - Deploy

on:
  workflow_run:
    workflows: ["ECR - Build & Push"]
    types: [completed]
  workflow_dispatch:

concurrency:
  group: ecs-main
  cancel-in-progress: false

permissions:
  contents: read

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: kickytime-repo        # ECR ë¦¬í¬ ì´ë¦„
  ECS_CLUSTER: kickytime-cluster        # ECS í´ëŸ¬ìŠ¤í„° ì´ë¦„
  ECS_SERVICE: kickytime-task-service   # ECS ì„œë¹„ìŠ¤ ì´ë¦„
  TASK_FAMILY: kickytime-task           # íƒœìŠ¤í¬ ì •ì˜ íŒ¨ë°€ë¦¬
  CONTAINER_NAME: kickytime-ecr         # TD ì•ˆ ì»¨í…Œì´ë„ˆ ì´ë¦„(ì •í™•ížˆ ì¼ì¹˜)
  # (ì„ íƒ) ALB íƒ€ê²Ÿê·¸ë£¹ ARNì„ Secretì— ë„£ì—ˆë‹¤ë©´ ì•„ëž˜ì²˜ëŸ¼ êº¼ë‚´ ì“°ì„¸ìš”.
  # TG_ARNì€ ë””ë²„ê¹…ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
  # TG_ARN: ${{ secrets.ALB_TG_ARN }}

jobs:
  deploy:
    # ECR ì›Œí¬í”Œë¡œìš°ê°€ 'ì„±ê³µ'ì´ê³ , ëŒ€ìƒ ë¸Œëžœì¹˜ê°€ mainì¼ ë•Œë§Œ ì‹¤í–‰
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main' }}
    runs-on: ubuntu-latest
    env:
      HEAD_SHA: ${{ github.event.workflow_run.head_sha }}

    steps:
      - name: Checkout same commit (from ECR build)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.HEAD_SHA }}

      - name: Configure AWS credentials (Access Keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # ECRì—ì„œ ì‚¬ìš©í•œ ê²ƒê³¼ ë™ì¼í•œ íƒœê·¸(HEAD_SHA 12ìžë¦¬)ë¡œ ì´ë¯¸ì§€ URIë¥¼ ìž¬êµ¬ì„±
      - name: Compute IMAGE_URI (same tag as ECR)
        id: tag
        run: |
          TAG=${HEAD_SHA::12}
          echo "TAG=$TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_URI=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${TAG}" >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸ Using image: ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${TAG}"

      - name: Describe current Task Definition
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ env.TASK_FAMILY }}" \
            --query 'taskDefinition' > td.json

      - name: Patch image & strip metadata (keep env/secrets)
        run: |
          jq --arg NAME "${{ env.CONTAINER_NAME }}" --arg IMG "${{ steps.tag.outputs.IMAGE_URI }}" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMG else . end)
            | del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)
          ' td.json > td-new.json

      - name: Register new Task Definition
        id: register
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://td-new.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "TASK_DEF_ARN=$NEW_TD_ARN" >> $GITHUB_OUTPUT
          echo "âœ… New Task Definition: $NEW_TD_ARN"

      - name: Update service (rolling deployment)
        run: |
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "${{ steps.register.outputs.TASK_DEF_ARN }}" \
            --force-new-deployment

      # ðŸ” desiredCountê°€ 0ì´ë©´ ëª¨ë‹ˆí„°ë§ì„ ìŠ¤í‚µ (ì˜ë„ì  0-ìŠ¤ì¼€ì¼ í…ŒìŠ¤íŠ¸ ì§€ì›)
      - name: "Guard: skip when desiredCount == 0"
        id: guard
        run: |
          DESIRED=$(aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query 'services[0].desiredCount' --output text)
          echo "desiredCount=$DESIRED"
          if [ "$DESIRED" = "0" ]; then
            echo "SKIPPED=true" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ desiredCount is 0 â‡’ monitoring skipped by design."
          fi

      # â³ ì•ˆì •í™” ëŒ€ê¸° â€” ì‹¤íŒ¨ë¥¼ ìž¡ê³  ë„˜ì–´ê°€ì„œ ë””ë²„ê¹… ìŠ¤í…ì´ ì‹¤í–‰ë˜ê²Œ í•¨
      - name: Wait until service is stable (capture failure)
        id: wait
        if: steps.guard.outputs.SKIPPED != 'true'
        run: |
          set +e
          aws ecs wait services-stable \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}"
          STATUS=$?
          echo "WAIT_EXIT=$STATUS" >> $GITHUB_OUTPUT
          if [ $STATUS -ne 0 ]; then
            echo "âŒ Waiter failed (diagnostics will run next)."
          else
            echo "âœ… Service stabilized."
          fi

      # ðŸ§° ì‹¤íŒ¨ ì›ì¸ ë¤í”„ (ì„œë¹„ìŠ¤ ì´ë²¤íŠ¸/ë°°í¬/ìµœê·¼ STOPPED íƒœìŠ¤í¬)
      - name: Dump ECS service events
        if: steps.guard.outputs.SKIPPED != 'true' && steps.wait.outputs.WAIT_EXIT != '0'
        run: |
          aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query 'services[0].events[0:20].[createdAt,message]' \
            --output table

          aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query 'services[0].deployments' \
            --output json

      - name: Inspect last failed task
        if: steps.guard.outputs.SKIPPED != 'true' && steps.wait.outputs.WAIT_EXIT != '0'
        run: |
          ARNS=$(aws ecs list-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service-name "${{ env.ECS_SERVICE }}" \
            --desired-status STOPPED \
            --query 'taskArns' --output text)
          if [ -n "$ARNS" ]; then
            aws ecs describe-tasks \
              --cluster "${{ env.ECS_CLUSTER }}" \
              --tasks $ARNS \
              --query 'tasks[].{stoppedReason:stoppedReason,containers:containers[].reason,exitCode:containers[].exitCode,lastStatus:lastStatus}' \
              --output table
          else
            echo "No STOPPED tasks found."
          fi

      # (ì„ íƒ) ALB íƒ€ê²Ÿê·¸ë£¹ í—¬ìŠ¤ â€” TG_ARNì„ ì•Œê³  ìžˆì„ ë•Œë§Œ
      - name: Target group target health (optional)
        if: steps.guard.outputs.SKIPPED != 'true' && steps.wait.outputs.WAIT_EXIT != '0' && env.TG_ARN != ''
        run: |
          aws elbv2 describe-target-health --target-group-arn "${{ env.TG_ARN }}" \
            --query 'TargetHealthDescriptions[].TargetHealth' --output table || true

      # âŒ ì—¬ê¸°ì„œ ìµœì¢… ì‹¤íŒ¨ ì²˜ë¦¬ (ìœ„ì—ì„œ ì§„ë‹¨ ë¡œê·¸ë¥¼ ë‚¨ê¸´ í›„ ì‹¤íŒ¨)
      - name: Fail job (service did not stabilize)
        if: steps.guard.outputs.SKIPPED != 'true' && steps.wait.outputs.WAIT_EXIT != '0'
        run: |
          echo "âŒ Service did not stabilize. See diagnostics above."
          exit 1

      # âœ… ì„±ê³µ ë˜ëŠ” ìŠ¤í‚µ ìš”ì•½
      - name: Summary
        if: steps.guard.outputs.SKIPPED == 'true' || steps.wait.outputs.WAIT_EXIT == '0'
        run: |
          echo "### ðŸš€ ECS Deploy Completed" >> $GITHUB_STEP_SUMMARY
          echo "- Cluster: \`${{ env.ECS_CLUSTER }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Service: \`${{ env.ECS_SERVICE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- TD: \`${{ steps.register.outputs.TASK_DEF_ARN }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`${{ steps.tag.outputs.IMAGE_URI }}\`" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.guard.outputs.SKIPPED }}" = "true" ]; then
            echo "- Note: desiredCount=0 (monitoring skipped by design)" >> $GITHUB_STEP_SUMMARY
          fi
